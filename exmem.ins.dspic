;   ***************************************************************
;   * Copyright (C) 2024, Embed Inc (http://www.embedinc.com)     *
;   *                                                             *
;   * Permission to copy this file is granted as long as this     *
;   * copyright notice is included in its entirety at the         *
;   * beginning of the file, whether the file is copied in whole  *
;   * or in part and regardless of whether other information is   *
;   * added to the copy.                                          *
;   *                                                             *
;   * The contents of this file may be used in any way,           *
;   * commercial or otherwise.  This file is provided "as is",    *
;   * and Embed Inc makes no claims of suitability for a          *
;   * particular purpose nor assumes any liability resulting from *
;   * its use.                                                    *
;   ***************************************************************
;
;   Extended data memory management and access.
;
/const   exmstart integer = 16#8000 ;extended memory start address

/block
  /var local ii integer
  /var local s string

  /if [not [exist "exmem_last:vcon"]] then
    /const exmem_last integer = 16#FFFF
    /endif

  /const win1 bool = [<= exmem_last 16#FFFF] ;there is only a single extended RAM window ?

  /set ii [- exmem_last 16#7FFF] ;make raw size of extended memory
  /set ii [max ii 0]         ;clip negative values to 0
  /const exmem_size integer = ii ;size of extended part of overall data memory

  /set ii [- exmem_last 1]   ;last address with 2 bytes left
  /set ii [and ii [~ 1]]     ;make sure to start at word boundary
  /set ii [+ ii 2]           ;first FREEADR adr with 0 space left
  /const free0 integer = ii  ;start of free memory adr for exactly 0 mem left

  /set ii [+ exmem_last 1]   ;total addressable data mem range
  /set ii [- ii 4096]        ;minus special function register space
  /set s ""
  /append s ii " bytes"
  /set ii [div ii 1024]
  /append s " (" ii "k) total data RAM"
  /set ii [- ii 28]
  /set ii [div [+ ii 31] 32]
  /append s " using " ii " extended memory window"
  /if [<> ii 1] then
    /append s "s"
    /endif
  /show "  " s
  /endblock

;*******************************************************************************
;
;   Variables.
;
.section .ram_exmem, bss     ;variables in normal RAM

alloc    freeadr 4           ;address of first free byte, always word-aligned


.section .code_exmem, code
////////////////////////////////////////////////////////////////////////////////
//
//   Macro SET_EXREAD scrreg, erradr
//
//   Set up the hardware for reading the extended memory at W3:W2.
//
//   SCRREG is the name of a register that can be used as scratch.  This
//   register will be trashed.  It must not be W2, W3, or W15.  The parameter is
//   the name of a register directly, like "w5", not a string.
//
//   ERRADR is an address or name of a label to jump to on error.  It is the
//   label directly, not a string.
//
//   The DSRPAG register will be set up so that an indirect read thru W2 will
//   get the data at the extended memory address W3:W2.
//
//   On success (not jump to ERRADR), the original contents of the DSRPAG
//   register is pushed onto the stack.
//
/macro set_exread
         ;
         ;   Set up for reading from extended memory at W3:W2.
         ;
         mov     #0x007F, [arg 1] ;get mask for largest allowed address
         cp      w3, [arg 1] ;compare requested address to max allowed
         bra     gtu, [arg 2] ;invalid extended memory address ?

         mov     Dsrpag, [arg 1] ;save original DSRPAG on the stack
         push    [arg 1]

         rlc     w2, [arg 1] ;get adr bit 15 into C
         mov     w3, [arg 1] ;get unshifted high address bits
         rlc     [arg 1], [arg 1] ;make high address bits starting at 15
         mov     [arg 1], Dsrpag ;set extended memory window to read from
  /write
  /endmac

////////////////////////////////////////////////////////////////////////////////
//
//   Macro SET_EXWRITE scrreg, erradr
//
//   Set up the hardware for writing to the extended memory at W3:W2.
//
//   SCRREG is the name of a register that can be used as scratch.  This
//   register will be trashed.  It must not be W2, W3, or W15.  The parameter is
//   the name of a register directly, like "w5", not a string.
//
//   ERRADR is an address or name of a label to jump to on error.  It is the
//   label directly, not a string.
//
//   The DSWPAG register will be set up so that an indirect write thru W2 will
//   write to the extended memory address W3:W2.
//
/macro set_exwrite
         ;
         ;   Set up for writing to extended memory at W3:W2.
         ;
         mov     #0x007F, [arg 1] ;get mask for largest allowed address
         cp      w3, [arg 1] ;compare requested address to max allowed
         bra     gtu, [arg 2] ;invalid extended memory address ?

         rlc     w2, [arg 1] ;get adr bit 15 into C
         mov     w3, [arg 1] ;get unshifted high address bits
         rlc     [arg 1], [arg 1] ;make high address bits starting at 15
         mov     [arg 1], Dswpag ;set extended memory window to read from
  /write
  /endmac

;*******************************************************************************
;
;   Subroutine EXMEM_INIT
;
;   Initialize the hardware and software state managed by this module.
;
         glbsub  exmem_init

         mcall   exmem_alloc_reset ;reset all dynamic memory to unallocated

         leaverest

;*******************************************************************************
;
;   Subroutine EXMEM_ALLOC_RESET
;
;   Reset the dynamic memory state to all memory unallocated.
;
         glbsubd exmem_alloc_reset, regf0

         mov     #[loww exmstart], w0 ;next alloc at start of extended mem
         mov     w0, freeadr+0
         mov     #[highw exmstart], w0
         mov     w0, freeadr+2

         leaverest

;*******************************************************************************
;
;   Subroutine EXMEM_ALLOC_AVAIL
;
;   Return the remaining amount of allocatable memory in W1:W0.
;
         glbsubd exmem_alloc_avail, regf2

         load32  w0, free0   ;get alloc address for no mem left

         mov     freeadr+0, w2 ;subtract current allocation address
         sub     w0, w2, w0
         mov     freeadr+2, w2
         subb    w1, w2, w1

         leaverest

;*******************************************************************************
;
;   Subroutine EXMEM_ALLOC_PERM
;
;   Allocate a block of extended data memory.  On entry, W1:W0 is the number of
;   bytes to allocate.  On success, W1:W0 is returned the starting address of
;   the new block and the Z flag is cleared.  On failure, the Z flag is set and
;   W1:W0 will be 0.  The only cause for failure is insufficient unallocated
;   memory available.
;
         glbsubd exmem_alloc_perm, regf2 | regf3 | regf4

         add     w0, #1, w0  ;round requested size up to whole words
         addc    w1, #0, w1
         bclr    w0, #0
;
;   Make updated free region start address in W3:W2.  Abort with error if this
;   would be past FREE0.
;
         mov     freeadr+0, w2 ;get the existing free address
         mov     freeadr+2, w3
         add     w2, w0, w2  ;add requested size to make new free address
         addc    w3, w1, w3

         mov     #[loww free0], w4
         cp      w4, w2
         mov     #[highw free0], w4
         cpb     w4, w3
         bra     ltu, allperm_err ;new free pointer would be too far ?
;
;   The requested amount of memory is available.  W3:W2 contains the free
;   pointer after the newly allocated region.
;
         mov     freeadr+0, w0 ;return pointer to new region
         mov     freeadr+2, w1

         mov     w2, freeadr+0 ;update free pointer to after new region
         mov     w3, freeadr+2

         bclr    Sr, #Z      ;indicate success

allperm_leave:
         leaverest
;
;   The requested amount of memory exceeds the available unallocated memory.
;
allperm_err:
         mov     #0, w0      ;return 0 starting address
         mov     #0, w1
         bset    Sr, #Z      ;indicate failure
         jump    allperm_leave

;*******************************************************************************
;
;   Subroutine EXMEM_PUT8
;
;   Write the low 8 bits of W0 to the extended memory byte at W3:W2.  W3:W2 is
;   updated to immediately after the written data.  Nothing is done if the
;   address in W3:W2 is invalid.
;
_exmem_put8u glblab          ;C version entry points
_exmem_put8s glblab
;
;   Assembler version.
;
         glbsub  exmem_put8, regf4

         set_exwrite w4, put8_leave ;set up extended memory write window

         nop                 ;leave time after DSWPAG change
         mov.b   w0, [w2]    ;do the write

         add     w2, #1, w2  ;increment the address
         addc    w3, #0, w3

put8_leave:
         leaverest

;*******************************************************************************
;
;   Subroutine EXMEM_PUT16
;
;   Write the contents of W0 to the extended memory at W3:W2.  W3:W2 is updated
;   to immediately after the written data.  Nothing is done if the address in
;   W3:W2 is invalid.
;
_exmem_put16u glblab         ;C version entry points
_exmem_put16s glblab
;
;   Assembler version.
;
         glbsub  exmem_put16, regf4

         set_exwrite w4, put16_leave ;set up extended memory write window

         btsc    w2, #0      ;word aligned ?
         jump    put16_byte  ;no, handle unaligned access
;
;   The target address is word-aligned.
;
         mov     w0, [w2]    ;do the write
;
;   Done with the write.  Increment the caller's address and leave.
;
put16_dwrite:
         add     w2, #2, w2  ;increment the address
         addc    w3, #0, w3

put16_leave:
         leaverest
;
;   The target address is not word-aligned.
;
put16_byte:                  ;target is not word-aligned
         mov.b   w0, [w4++]  ;write byte 0

         swap    w0          ;write byte 1
         mov.b   w0, [w4++]
         swap    w0          ;restore original W0

         jump    put16_dwrite ;done with the actual write

;*******************************************************************************
;
;   Subroutine EXMEM_PUT24
;
;   Write the low 24 bits of W1:W0 to the extended memory at W3:W2.  W3:W2 is
;   updated to immediately after the written data.  Nothing is done if the
;   address in W3:W2 is invalid.
;
_exmem_put24u glblab         ;C version entry points
_exmem_put24s glblab
;
;   Assembler version.
;
         glbsub  exmem_put24, regf4

         set_exwrite w4, put24_leave ;set up extended memory write window
         mov     w2, w4      ;make corruptable copy of target address

         btsc    w2, #0      ;word aligned ?
         jump    put24_byte  ;no, handle unaligned access
;
;   The target address is word-aligned.
;
         mov     w0, [w4++]  ;write low 16 bits
         mov.b   w1, [w4]    ;write high 8 bits
;
;   Done with the write.  Increment the caller's address and leave.
;
put24_dwrite:
         add     w2, #3, w2  ;increment the address
         addc    w3, #0, w3

put24_leave:
         leaverest
;
;   The target address is not word-aligned.
;
put24_byte:                  ;target is not word-aligned
         mov.b   w0, [w4++]  ;write byte 0

         swap    w0          ;write byte 1
         mov.b   w0, [w4++]
         swap    w0          ;restore original W0

         mov.b   w1, [w4]    ;write byte 2

         jump    put24_dwrite ;done with the actual write

;*******************************************************************************
;
;   Subroutine EXMEM_PUT32
;
;   Write the contents of W1:W0 to the extended memory at W3:W2.  W3:W2 is
;   updated to immediately after the written data.  Nothing is done if the
;   address in W3:W2 is invalid.
;
_exmem_put32u glblab         ;C version entry points
_exmem_put32s glblab
_exmem_putfp32 glblab
;
;   Assembler version.
;
         glbsub  exmem_put32, regf4

         set_exwrite w4, put32_leave ;set up extended memory write window
         mov     w2, w4      ;make corruptable copy of target address

         btsc    w2, #0      ;word aligned ?
         jump    put32_byte  ;no, handle unaligned access
;
;   The target address is word-aligned.
;
         mov     w0, [w4++]  ;write low 16 bits
         mov     w1, [w4]    ;write high 16 bits
;
;   Done with the write.  Increment the caller's address and leave.
;
put32_dwrite:
         add     w2, #4, w2  ;increment the address
         addc    w3, #0, w3

put32_leave:
         leaverest
;
;   The target address is not word-aligned.
;
put32_byte:                  ;target is not word-aligned
         mov.b   w0, [w4++]  ;write byte 0

         swap    w0          ;write byte 1
         mov.b   w0, [w4++]
         swap    w0          ;restore original W0

         mov.b   w1, [w4++]  ;write byte 2

         swap    w1          ;write byte 3
         mov.b   w1, [w4]
         swap    w1          ;restore original W1

         jump    put32_dwrite ;done with the actual write

;*******************************************************************************
;
;   Subroutine EXMEM_PUTBUF
;
;   Copy a sequence of bytes from regular data memory to extended data memory.
;   W0 contains the start address of the regular memory buffer, and W1 its
;   length in bytes.  W3:W2 is the address of the destination buffer in extended
;   memory.  W0 and  W3:W2 are each incremented by the number of bytes copied.
;
;   Nothing is done if the address in W3:W2 is invalid.  No data is copied and
;   the addresses are not incremented.
;
         glbsubd exmem_putbuf, regf4 | regf5
;
;   Register usage:
;
;     W0  -  Regular memory word or byte address.  Original saved on stack
;            during copy.
;
;     W1  -  Buffer size in bytes.
;
;     W3:W2  -  Extended memory buffer start address.
;
;     W4  -  Current index into extended memory window.
;
;     W5  -  Number of whole aligned 16 bits words to copy.
;
         cp0     w1
         bra     z, putbuf_leave ;empty buffer, nothing to do ?

         set_exwrite w4, putbuf_leave ;set up extended memory write window
         mov     w2, w4      ;make corruptable copy of extended mem index
         push    w0          ;save original regular mem pointer

         xor     w0, w2, w5
         btsc    w5, #0      ;both buffers have same alignment ?
         jump    putbuf_misaln ;no, handle special case of different alignments

         btsc    w2, #0      ;word aligned ?
         jump    putbuf_odd  ;no, handle unaligned access
;
;   The buffers are word-aligned.  The whole aligned 16 bits words are copied
;   first, possibly followed by one remaining byte.
;
         lsr     w1, #1, w5  ;make number of whole words to copy
         bra     z, putbuf_lastbyte ;buffer is only a single byte long ?

         sub     #1, w5      ;make value for REPEAT instruction
         repeat  w5          ;run next instruction W5+1 times
         mov     [w0++], [w4++] ;copy all the whole words of the buffer

         btss    w1, #0      ;buffer is odd number of bytes long ?
         jump    putbuf_dwrite ;no, the whole write has been completed

putbuf_lastbyte:             ;there is one remaining single byte to copy
         mov.b   [w0], [w4]  ;copy the last byte
;
;   Done with the write.  Increment the caller's addresses and leave.  The
;   original regular memory pointer is saved on the stack.
;
putbuf_dwrite:
         pop     w0          ;restore original regular memory pointer
         add     w0, w1, w0  ;update regular memory pointer

         add     w2, w1, w2  ;update extended memory pointer
         addc    w3, #0, w3

putbuf_leave:
         leaverest
;
;   The buffers are not word aligned.  The single unaligned byte is copied, then
;   the whole aligned words, then possibly a remaining single byte.
;
putbuf_odd:
         mov.b   [w0++], [w4++] ;copy the first (at odd address) byte
         ;
         ;   Copy the whole aligned 16 bit words, if any.
         ;
         sub     w1, #1, w5  ;remaining number of bytes to copy
         lsr     w5, #1, w5  ;number of whole words that can be copied
         bra     z, putbuf_dbwhole ;no whole words to copy ?

         sub     #1, w5      ;make value for REPEAT instruction
         repeat  w5          ;run next instruction W5+1 times
         mov     [w0++], [w4++] ;copy all the whole words of the buffer
putbuf_dbwhole:              ;done copying the whole aligned words
         ;
         ;   Check for possible single remaining byte to copy.  Since the buffer
         ;   started at an odd address, this is the case if the buffer length is
         ;   even.
         ;
         btsc    w1, #0      ;buffer even bytes long, so ends with odd byte ?
         jump    putbuf_dwrite ;no remaining odd byte, done with copy
         jump    putbuf_lastbyte ;ends with odd byte, go copy it
;
;   The two buffers have different alignments.  One is word-aligned, but the
;   other is not.  This means direct word transfers can't be used because either
;   the source or destination of each word would be unaligned.  We give up and
;   copy each byte individually.
;
putbuf_misaln:
         sub     w1, #1, w5  ;make value for the REPEAT instruction
         repeat  w5          ;run next instruction W5+1 number of times
         mov.b   [w0++], [w4++] ;copy all the buffer bytes
         jump    putbuf_dwrite ;done copying the whole buffer

;*******************************************************************************
;
;   Subroutine EXMEM_GET8U
;
;   Read the unsigned byte at the extended memory address in W3:W2 into W0.
;   W3:W2 is updated to immediately after the data that is read.  When the
;   address is invalid, 0 is returned and W3:W2 not altered.
;
_exmem_get8u glblab          ;C version entry point
         mov.d   w0, w2      ;move address into W3:W2
;
;   Assembler version.
;
         glbsub  exmem_get8u, regf4

         set_exread w4, get8u_badadr ;save DSRPAG, set up ext mem read window

         nop                 ;leave time after DSRPAG change
         ze      [w2], w0    ;do the read

         add     w2, #1, w2  ;increment the address
         addc    w3, #0, w3

         pop     w4          ;restore the original DSRPAG contents
         mov     w4, Dsrpag

get8u_leave:
         leaverest
;
;   The extended memory address is invalid.
;
get8u_badadr:
         mov     #0, w0      ;return 0
         jump    get8u_leave

;*******************************************************************************
;
;   Subroutine EXMEM_GET8S
;
;   Read the signed byte at the extended memory address in W3:W2 into W0.  W3:W2
;   is updated to immediately after the data that is read.  When the address is
;   invalid, 0 is returned and W3:W2 not altered.
;
_exmem_get8s glblab          ;C version entry point
         mov.d   w0, w2      ;move address into W3:W2
;
;   Assembler version.
;
         glbsub  exmem_get8s, regf4

         set_exread w4, get8s_badadr ;save DSRPAG, set up ext mem read window

         nop                 ;leave time after DSRPAG change
         se      [w2], w0    ;do the read

         add     w2, #1, w2  ;increment the address
         addc    w3, #0, w3

         pop     w4          ;restore the original DSRPAG contents
         mov     w4, Dsrpag

get8s_leave:
         leaverest
;
;   The extended memory address is invalid.
;
get8s_badadr:
         mov     #0, w0      ;return 0
         jump    get8s_leave

;*******************************************************************************
;
;   Subroutine EXMEM_GET16
;
;   Read the 16-bit word at the extended memory address in W3:W2 into W0.
;   W3:W2 is updated to immediately after the data that is read.  When the
;   address is invalid, 0 is returned and W3:W2 not altered.
;
_exmem_get16u glblab         ;C version entry points
_exmem_get16s glblab
         mov.d   w0, w2      ;move address into W3:W2
;
;   Assembler version.
;
         glbsub  exmem_get16, regf4

         set_exread w4, get16_badadr ;save DSRPAG, set up ext mem read window

         btsc    w2, #0      ;word aligned ?
         jump    get16_byte  ;no, handle unaligned access
;
;   The extended memory address is word-aligned.
;
         mov     [w2], w0    ;do the read
;
;   Done with the read.
;
get16_dread:
         add     w2, #2, w2  ;increment the address
         addc    w3, #0, w3

         pop     w4          ;restore the original DSRPAG contents
         mov     w4, Dsrpag

get16_leave:
         leaverest
;
;   The extended memory address is not word-aligned.
;
get16_byte:
         push    w2          ;save original read pointer
         mov.b   [w2++], w0  ;read the low byte
         swap    w0          ;temp save in high byte
         mov.b   [w2], w0    ;read the high byte
         swap    w0          ;reassemble word with correct byte order
         pop     w2          ;restore original read pointer
         jump    get16_dread ;done with the actual read
;
;   The extended memory address is invalid.
;
get16_badadr:
         mov     #0, w0      ;return 0
         jump    get16_leave

;*******************************************************************************
;
;   Subroutine EXMEM_GET24U
;
;   Read the 24-bit unsigned word at the extended memory address in W3:W2 into
;   W1:W0.  W3:W2 is updated to immediately after the data that is read.  When
;   the address is invalid, 0 is returned and W3:W2 not altered.
;
_exmem_get24u glblab         ;C version entry point
         mov.d   w0, w2      ;move address into W3:W2
;
;   Assembler version.
;
         glbsub  exmem_get24u

         set_exread w0, get24u_badadr ;save DSRPAG, set up ext mem read window
         push    w2          ;save original read pointer

         btsc    w2, #0      ;word aligned ?
         jump    get24u_byte ;no, handle unaligned access
;
;   The extended memory address is word-aligned.
;
         mov     [w2++], w0  ;read the low word
         ze      [w2], w1    ;read the high byte
;
;   Done with the read.
;
get24u_dread:
         mov     [w15-4], w2 ;restore original DSRPAG contents
         mov     w2, Dsrpag

         pop     w2          ;restore original read pointer
         add     w2, #3, w2  ;increment the address
         addc    w3, #0, w3

         sub     #2, w15     ;remove saved DSRPAG from stack

get24u_leave:
         leaverest
;
;   The extended memory address is not word-aligned.
;
get24u_byte:
         mov.b   [w2++], w0  ;read byte 0
         swap    w0          ;temp save in high byte
         mov.b   [w2++], w0  ;read byte 1
         swap    w0          ;assemble final low word
         ze      [w2], w1    ;read byte 2
         jump    get24u_dread ;done with the actual read
;
;   The extended memory address is invalid.
;
get24u_badadr:
         mul.uu  w0, #0, w0  ;return 0 in W1:W0
         jump    get24u_leave

;*******************************************************************************
;
;   Subroutine EXMEM_GET24S
;
;   Read the 24-bit signed word at the extended memory address in W3:W2 into
;   W1:W0.  W3:W2 is updated to immediately after the data that is read.  When
;   the address is invalid, 0 is returned and W3:W2 not altered.
;
_exmem_get24s glblab         ;C version entry point
         mov.d   w0, w2      ;move address into W3:W2
;
;   Assembler version.
;
         glbsub  exmem_get24s

         set_exread w0, get24s_badadr ;save DSRPAG, set up ext mem read window
         push    w2          ;save original read pointer

         btsc    w2, #0      ;word aligned ?
         jump    get24s_byte ;no, handle unaligned access
;
;   The extended memory address is word-aligned.
;
         mov     [w2++], w0  ;read the low word
         se      [w2], w1    ;read the high byte
;
;   Done with the read.
;
get24s_dread:
         mov     [w15-4], w2 ;restore original DSRPAG contents
         mov     w2, Dsrpag

         pop     w2          ;restore original read pointer
         add     w2, #3, w2  ;increment the address
         addc    w3, #0, w3

         sub     #2, w15     ;remove saved DSRPAG from stack

get24s_leave:
         leaverest
;
;   The extended memory address is not word-aligned.
;
get24s_byte:
         mov.b   [w2++], w0  ;read byte 0
         swap    w0          ;temp save in high byte
         mov.b   [w2++], w0  ;read byte 1
         swap    w0          ;assemble final low word
         se      [w2], w1    ;read byte 2
         jump    get24s_dread ;done with the actual read
;
;   The extended memory address is invalid.
;
get24s_badadr:
         mul.uu  w0, #0, w0  ;return 0 in W1:W0
         jump    get24s_leave

;*******************************************************************************
;
;   Subroutine EXMEM_GET32
;
;   Read the 32-bit word at the extended memory address in W3:W2 into W1:W0.
;   W3:W2 is updated to immediately after the data that is read.  When the
;   address is invalid, 0 is returned and W3:W2 not altered.
;
_exmem_get32u glblab         ;C version entry points
_exmem_get32s glblab
_exmem_getfp32 glblab
         mov.d   w0, w2      ;move address into W3:W2
;
;   Assembler version.
;
         glbsub  exmem_get32

         set_exread w0, get32_badadr ;save DSRPAG, set up ext mem read window
         push    w2          ;save original read pointer

         btsc    w2, #0      ;word aligned ?
         jump    get32_byte  ;no, handle unaligned access
;
;   The extended memory address is word-aligned.
;
         mov     [w2++], w0  ;read the low word
         mov     [w2], w1    ;read the high word
;
;   Done with the read.
;
get32_dread:
         mov     [w15-4], w2 ;restore original DSRPAG contents
         mov     w2, Dsrpag

         pop     w2          ;restore original read pointer
         add     w2, #4, w2  ;increment the address
         addc    w3, #0, w3

         sub     #2, w15     ;remove saved DSRPAG from stack

get32_leave:
         leaverest
;
;   The extended memory address is not word-aligned.
;
get32_byte:
         mov.b   [w2++], w0  ;read byte 0
         swap    w0          ;temp save in high byte
         mov.b   [w2++], w0  ;read byte 1
         swap    w0          ;assemble final low word

         mov.b   [w2++], w1  ;read byte 2
         swap    w1          ;temp save in high byte
         mov.b   [w2], w1    ;read byte 3
         swap    w1          ;assemble final high word

         jump    get32_dread ;done with the actual read
;
;   The extended memory address is invalid.
;
get32_badadr:
         mul.uu  w0, #0, w0  ;return 0 in W1:W0
         jump    get32_leave

;*******************************************************************************
;
;   Subroutine EXMEM_GETBUF
;
;   Copy a sequence of bytes from extended data memory to regular data memory.
;   W0 contains the start address of the regular memory buffer, and W1 its
;   length in bytes.  W3:W2 is the address of the source buffer in extended
;   memory.  W0 and  W3:W2 are each incremented by the number of bytes copied.
;
;   Nothing is done if the address in W3:W2 is invalid.  No data is copied and
;   the addresses are not incremented.
;
         glbsubd exmem_getbuf, regf4 | regf5
;
;   Register usage:
;
;     W0  -  Regular memory word or byte address.  Original saved on stack
;            during copy.
;
;     W1  -  Buffer size in bytes.
;
;     W3:W2  -  Extended memory buffer start address.
;
;     W4  -  Current index into extended memory window.
;
;     W5  -  Number of whole aligned 16 bits words to copy.
;
         cp0     w1
         bra     z, getbuf_leave ;empty buffer, nothing to do ?

         set_exread w4, getbuf_leave ;save DSRPAG, set up ext mem read window
         mov     w2, w4      ;make corruptable copy of extended mem index
         push    w0          ;save original regular mem pointer

         xor     w0, w2, w5
         btsc    w5, #0      ;both buffers have same alignment ?
         jump    getbuf_misaln ;no, handle special case of different alignments

         btsc    w2, #0      ;word aligned ?
         jump    getbuf_odd  ;no, handle unaligned access
;
;   The buffers are word-aligned.  The whole aligned 16 bits words are copied
;   first, possibly followed by one remaining byte.
;
         lsr     w1, #1, w5  ;make number of whole words to copy
         bra     z, getbuf_lastbyte ;buffer is only a single byte long ?

         sub     #1, w5      ;make value for REPEAT instruction
         repeat  w5          ;run next instruction W5+1 times
         mov     [w4++], [w0++] ;copy all the whole words of the buffer

         btss    w1, #0      ;buffer is odd number of bytes long ?
         jump    getbuf_dwrite ;no, the whole write has been completed

getbuf_lastbyte:             ;there is one remaining single byte to copy
         mov.b   [w4], [w0]  ;copy the last byte
;
;   Done with the write.  Increment the caller's addresses and leave.  The
;   original regular memory pointer is saved on the stack.
;
getbuf_dwrite:
         pop     w0          ;restore original regular memory pointer
         add     w0, w1, w0  ;update regular memory pointer

         pop     w4          ;restore original DSRPAG contents
         mov     w4, Dsrpag

         add     w2, w1, w2  ;update extended memory pointer
         addc    w3, #0, w3

getbuf_leave:
         leaverest
;
;   The buffers are not word aligned.  The single unaligned byte is copied, then
;   the whole aligned words, then possibly a remaining single byte.
;
getbuf_odd:
         mov.b   [w4++], [w0++] ;copy the first (at odd address) byte
         ;
         ;   Copy the whole aligned 16 bit words, if any.
         ;
         sub     w1, #1, w5  ;remaining number of bytes to copy
         lsr     w5, #1, w5  ;number of whole words that can be copied
         bra     z, getbuf_dbwhole ;no whole words to copy ?

         sub     #1, w5      ;make value for REPEAT instruction
         repeat  w5          ;run next instruction W5+1 times
         mov     [w4++], [w0++] ;copy all the whole words of the buffer

getbuf_dbwhole:              ;done copying the whole aligned words
         ;
         ;   Check for possible single remaining byte to copy.  Since the buffer
         ;   started at an odd address, this is the case if the buffer length is
         ;   even.
         ;
         btsc    w1, #0      ;buffer even bytes long, so ends with odd byte ?
         jump    getbuf_dwrite ;no remaining odd byte, done with copy
         jump    getbuf_lastbyte ;ends with odd byte, go copy it
;
;   The two buffers have different alignments.  One is word-aligned, but the
;   other is not.  This means direct word transfers can't be used because either
;   the source or destination of each word would be unaligned.  We give up and
;   copy each byte individually.
;
getbuf_misaln:
         sub     w1, #1, w5  ;make value for the REPEAT instruction
         repeat  w5          ;run next instruction W5+1 number of times
         mov.b   [w4++], [w0++] ;copy all the buffer bytes
         jump    getbuf_dwrite ;done copying the whole buffer

;*******************************************************************************
;*******************************************************************************
;
;   Commands.
;
;   These commands are not included in the code unless specifically enabled with
;   preprocessor constants in the client firmware.  The code for a command is
;   only included when a constant "cmd_<name>" has been defined.  This is
;   usually done in the xxx_CMDRSP.INS.DSPIC file of the client firmware.
;
;   The table below lists the available commands with any responses required to
;   be defined by those commands:
;
;     Command        |  Response       |  Description
;     --------------------------------------------------------------------------
;     EXMEM          |  EXMEM          |  Exmem configuration and curr status
;                    |                 |
;     EXMEM_RESET    |                 |  Reset to all exmem to unallocated.
;                    |                 |
;     EXMEM_ALLOC    |  EXMEM_ALLOC    |  Allocate exmem region.
;                    |                 |
;     EXMEM_AVAIL    |  EXMEM_AVAIL    |  Get amount of exmem avail to allocate.
;                    |                 |
;     EXMEM_PUTREG   |  EXMEM_ADR      |  Write to exmem from register.
;                    |                 |
;     EXMEM_PUTBUFE  |  EXMEM_ADR2     |  Write from even-aligned buffer of data
;                    |                 |  to exmem.
;                    |                 |
;     EXMEM_PUTBUFO  |  EXMEM_ADR2     |  Write from odd-aligned buffer of data
;                    |                 |  to exmem.
;                    |                 |
;     EXMEM_GETREG   |  EXMEM_REGDAT   |  Read 4 bytes of exmem into registers
;                    |                 |  in various formats.
;                    |                 |
;     EXMEM_GETBUFE  |  EXMEM_BUFDAT   |  Read exmem into even-aligned buffer
;                    |                 |
;     EXMEM_GETBUFO  |  EXMEM_BUFDAT   |  Read exmem into odd-aligned buffer
;                    |                 |
;

;*******************************************************************************
;
;   Command EXMEM
;
;   Causes the EXMEM response to be sent, which provides information and current
;   status of the extended data memory system:
;
;     EXMEM: lastadr orig left
;
;       LASTADR is the 32 bit address of the last byte of extended memory in
;       this processor.
;
;       ORIG is the 32 bit original amount of allocatable extended memory, in
;       bytes.  This is the amount available at system startup or after a
;       EXMEM_RESET command.
;
;       LEFT is the 32 bit amount of allocatable extended memory currently
;       available, in bytes.  This is the same as ORIG at startup and after a
;       EXMEM_RESET command, and is decreased after each successful allocation.
;
/if [Command cm_exmem] then
         gcall   cmd_lock_out ;acquire lock on response stream
         mov     #[v rsp_exmem], w0 ;send EXMEM response opcode
         gcall   cmd_put8

         load32  w0, exmem_last ;send LASTADR
         gcall   cmd_put32

         load32  w0, free0   ;send ORIG
         mov     #[loww exmstart], w2
         sub     w0, w2, w0
         mov     #[highw exmstart], w2
         subb    w1, w2, w1
         gcall   cmd_put32

         mcall   exmem_alloc_avail ;send LEFT
         gcall   cmd_put32
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_RESET
;
;   Reset all extended data memory to unallocated.
;
/if [Command cm_exmem_reset] then
         mcall   exmem_alloc_reset
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_ALLOC size
;
;   Attempt to allocate SIZE bytes of extended data memory.  SIZE is 32 bits.
;   Sends response:
;
;     EXMEM_ALLOC: flags adr
;
;       FLAGS is a collection of individual bits.  Bit 0 is set on failure to
;       allocate the memory, and cleared on success.  The remaining bits are
;       reserved for future use and are 0 for now.
;
;       ADR is the 32 bit starting address of the new region on success, and 0
;       on failure.
;
/if [Command cm_exmem_alloc] then
         gcall   cmd_get32   ;get amount of memory to request into W1:W0

         mcall   exmem_alloc_perm ;try to allocate the memory, adr in W1:W0
         mov     #0, w2      ;save Z flag in W2 bit 0
         skip_nz
         bset    w2, #0
         mov     w0, w3      ;returned address now saved in W1:W3

         gcall   cmd_lock_out ;acquire lock on response stream
         mov     #[v rsp_exmem_alloc], w0
         gcall   cmd_put8    ;send EXMEM_ALLOC response opcode
         mov     w2, w0
         gcall   cmd_put8    ;send FLAGS
         mov     w3, w0
         gcall   cmd_put32   ;send ADR
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_AVAIL
;
;   Sends the response:
;
;     EXMEM_AVAIL: size
;
;       Size the 32 bit amount of extended memory currently available for
;       allocation.
;
/if [Command cm_exmem_avail] then
         gcall   cmd_lock_out ;acquire lock on response stream
         mov     #[v rsp_exmem_avail], w0
         gcall   cmd_put8    ;send EXMEM_AVAIL response opcode

         mcall   exmem_alloc_avail ;get available memory into W1:W0
         gcall   cmd_put32   ;send SIZE
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_PUTREG adr n dat
;
;   Tests one of the EXMEM_PUTx routines.  ADR is the 32 bit address to write
;   to.  N is the number of bytes to write, and must be 1-4.  DAT is the 32 bit
;   value to write.
;
;   Only the low N bytes of DAT are written, using the routine for that many
;   bytes.  For example, when N is 2, the write is done by calling EXMEM_PUT16.
;   DAT is always 4 bytes and is always passed in W1:W0 regardless of how many
;   of those bytes are used.
;
;   Response:
;
;     EXMEM_ADR: adr
;
;       The new updated 32 bit address returned from the EXMEM_PUTx routine.
;
;   Nothing is done when N is not 1-4.
;
/if [Command cm_exmem_putreg] then
         gcall   cmd_get32   ;get the address into W3:W2
         mov.d   w0, w2
         gcall   cmd_get8    ;get the number of bytes to write into W4
         mov     w0, w4
         gcall   cmd_get32   ;get the data to write into W1:W0
;
;   Register contents:
;
;     W1:W0  -  Data to write.
;
;     W3:W2  -  Extended data memory address to write to.
;
;     W4  -  Number of bytes to write.  Only 1-4 supported.
;
         ;
         ;   Validate N.
         ;
         cp      w4, #1      ;check against lower limit
         skip_geu
         return

         cp      w4, #4      ;check against upper limit
         skip_leu
         return
         ;
         ;   Jump to separate code for each number of bytes to write.
         ;
         sub     #1, w4      ;make 0-3 jump offset
         bra     w4          ;index into next 4 instructions by W4
         bra     preg1
         bra     preg2
         bra     preg3
         bra     preg4
;
;   Jump targets.  Each PREGn target is for writing N bytes from W1:W0.
;
preg1:
         mcall   exmem_put8
         jump    preg_adr
preg2:
         mcall   exmem_put16
         jump    preg_adr
preg3:
         mcall   exmem_put24
         jump    preg_adr
preg4:
         mcall   exmem_put32
;
;   The write has been done.  Send an EXMEM_ADR response with the updated
;   address in W3:W2.
;
preg_adr:
         gcall   cmd_lock_out ;acquire lock on response stream
         mov     #[v rsp_exmem_adr], w0
         gcall   cmd_put8    ;send EXMEM_ADR response opcode

         mov.d   w2, w0      ;send the 32 bit address
         gcall   cmd_put32
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_PUTBUFE adr n dat ... dat
;
;   Tests EXMEM_PUTBUF with an even-aligned source buffer.  ADR is the 32 bit
;   extended data memory address to write to, N is the number of bytes to write
;   - 1, and DAT are the data bytes.  Exactly N+1 DAT bytes must follow N.
;
;   The following response is sent:
;
;   Response:
;
;     EXMEM_ADR2: adr1 adr2 adrex
;
;       The updated addresses returned by EXMEM_PUTBUF.  ADR1 is the 16 bit
;       regular memory source buffer address, and ADR2 is the updated version
;       returned by EXMEM_PUTBUF.  ADREX is the updated 32 bit extended data
;       memory address returned by EXMEM_PUTBUF.
;
;   The DAT bytes are read into the commands scratch buffer, which is then
;   passed to EXMEM_PUTBUF.  While all N+1 bytes will be read, those that do not
;   fit into the scratch buffer will be discarded.  Check the client firmware
;   implementation to find the size of the commands scratch buffer.
;
/if [Command cm_exmem_putbufe] then
         gcall   cmd_get32   ;get extended memory address into W3:W2
         mov.d   w0, w2
         gcall   cmd_get8    ;get number of data bytes into W0
         add     #1, w0
         gcall   cmd_putbufn ;get the data bytes into the commands scratch buffer

         mov     #cmdbuf, w0 ;pass source buffer address in W0
         mov     ncmdbuf, w1 ;pass number of bytes to copy in W1
         mcall   exmem_putbuf ;copy the buffer, addresses in W0, W3:W2 updated

         gcall   cmd_lock_out ;acquire exclusive lock on response stream
         mov     w0, w1      ;save updated regular mem buffer adr in W1
         mov     #[v rsp_exmem_adr2], w0 ;send EXMEM_ADR2 response opcode
         gcall   cmd_put8
         mov     #cmdbuf, w0 ;send regular mem buffer start address
         gcall   cmd_put16
         mov     w1, w0      ;send updated regular memory address
         gcall   cmd_put16
         mov.d   w2, w0      ;send updated extended memory address
         gcall   cmd_put32
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_PUTBUFO adr n dat ... dat
;
;   Same as EXMEM_PUTBUFE except that the source buffer will start on an odd
;   address.  The data bytes are read into the commands scratch buffer, except
;   that the first byte is not used so that the first data byte will be at an
;   odd address.  The maximum number of supported data bytes is therefore the
;   commands scratch buffer length - 1.  All DAT bytes are read, but only those
;   that fit into the scratch buffer are used.
;
;   A EXMEM_ADR2 response is sent.
;
/if [Command cm_exmem_putbufo] then
         gcall   cmd_get32   ;get extended memory address into W3:W2
         mov.d   w0, w2
         gcall   cmd_putbuf  ;dummy byte into buffer, next will be at odd address
         gcall   cmd_get8    ;get number of data bytes into W0
         add     #1, w0
         gcall   cmd_putbufn ;get the data bytes into the commands scratch buffer

         mov     #(cmdbuf+1), w0 ;pass source buffer address in W0
         mov     ncmdbuf, w1 ;pass number of bytes to copy in W1
         sub     #1, w1
         mcall   exmem_putbuf ;copy the buffer, addresses in W0, W3:W2 updated

         gcall   cmd_lock_out ;acquire exclusive lock on response stream
         mov     w0, w1      ;save updated regular mem buffer adr in W1
         mov     #[v rsp_exmem_adr2], w0 ;send EXMEM_ADR2 response opcode
         gcall   cmd_put8
         mov     #(cmdbuf+1), w0 ;send regular mem buffer start address
         gcall   cmd_put16
         mov     w1, w0      ;send updated regular memory address
         gcall   cmd_put16
         mov.d   w2, w0      ;send updated extended memory address
         gcall   cmd_put32
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_GETREG adr n
;
;   Read a word of extended memory into registers.  ADR is the 32 bit extended
;   memory address to read from.  N is the number of bytes to read in the low
;   7 bits, with the valid range being 1-4.  The high bit of N is 0 to read the
;   word as unsigned, and 1 for signed.
;
;   The following response is sent:
;
;     EXMEM_REGDAT: adr n dat
;
;       ADR is the updated address returned from the EXMEM_GETx routine.  N is
;       the number of bytes in the word, and whether it was signed or unsigned.
;       N has the same format a N in the command.  DAT is the full 32 bits in
;       W1:W0 on return from the EXMEM_GETx routine.  The data word is zero or
;       sign extended into the low 16 bits of dat when only 1 byte was read,
;       and extended into all 32 bits when 3 bytes were read.  The high 16 bits
;       are unused when 1 or 2 bytes were read.
;
/if [Command cm_exmem_getreg] then
         gcall   cmd_get32   ;get the extended memory address into W3:W2
         mov.d   w0, w2
         gcall   cmd_get8    ;get N into W0
         mov     w0, w4      ;save N parameter in W4
;
;   Jump to separate code for the number of data bytes and whether the word is
;   signed or unsigned.
;
         and     #0x7F, w0   ;mask in only the number of data bytes
         cp      w0, #1      ;compare against low limit
         skip_geu
         return
         cp      w0, #4      ;compare against high limit
         skip_leu
         return
         sub     #1, w0      ;make 0-3 offset for 1-4 bytes

         lsr     w4, #5, w5  ;get signed/unsigned into bit 2
         and     #0x04, w5   ;mask in only the signed/unsigned bit
         ior     w0, w5, w0  ;make 0-7 offset for number of bytes and signed
         bra     w0          ;index into jump table by W0
         bra     greg1u      ;1 byte, unsigned
         bra     greg2u      ;2 bytes, unsigned
         bra     greg3u      ;3 bytes, unsigned
         bra     greg4u      ;4 bytes, unsigned
         bra     greg1s      ;1 byte, signed
         bra     greg2s      ;2 bytes, signed
         bra     greg3s      ;3 bytes, signed
         bra     greg4s      ;4 bytes, signed
;
;   Individual routines jumped to from the jump table above.
;
greg1u:
         mcall   exmem_get8u
         jump    greg_rsp
greg2u:
         mcall   exmem_get16
         jump    greg_rsp
greg3u:
         mcall   exmem_get24u
         jump    greg_rsp
greg4u:
         mcall   exmem_get32
         jump    greg_rsp
greg1s:
         mcall   exmem_get8s
         jump    greg_rsp
greg2s:
         mcall   exmem_get16
         jump    greg_rsp
greg3s:
         mcall   exmem_get24s
         jump    greg_rsp
greg4s:
         mcall   exmem_get32
;
;   The extended memory read has been done.  The result is in W1:W0, the updated
;   address in W3:W2, and the original command N parameter in W4.
;
;   Now send the EXMEM_REGDAT response.
;
greg_rsp:
         mov.d   w0, w6      ;save the returned data word in W7:W6
         gcall   cmd_lock_out ;acquire exclusive lock on the response stream
         mov     #[v rsp_exmem_regdat], w0 ;send EXMEM_REGDAT response opcode
         gcall   cmd_put8

         mov.d   w2, w0      ;send the updated extended memory address
         gcall   cmd_put32

         mov     w4, w0      ;send the original N parameter
         gcall   cmd_put8

         mov.d   w6, w0      ;send the data value
         gcall   cmd_put32
         return
  /endif

;*******************************************************************************
;
;   Command EXMEM_GETBUFE adr n
;
;   Read extended memory bytes into a even-aligned regular memory buffer.  ADR
;   is the 32 bit extended memory address to start reading from.  N is the
;   number of bytes to read.
;
;   The data is read into the commands scratch buffer.  The number of bytes read
;   is limited to the size of that buffer.
;
;   The following response is sent:
;
;     EXMEM_BUFDAT: adrex adr n dat ... dat
;
;       ADR is the 32 bit extended memory address returned by EXMEM_GETBUF.  It
;       should be the first address after the bytes that were read.  ADR is the
;       updated address of the destination buffer in regular memory.  N is the
;       number of bytes that were read from extended memory, and could be 0.
;       DAT are the data bytes.  There are exactly N DAT bytes.
;
/if [Command cm_exmem_getbufe] then
         gcall   cmd_get32   ;get ADR into W3:W2
         mov.d   w0, w2
         gcall   cmd_get8    ;get N into w1
         mov     w0, w1
;
;   Clip N to the size of the commands scratch buffer.
;
         gcall   cmd_bufsize ;get scratch buffer size in W0
         cp      w1, w0
         skip_leu            ;existing N is within the buffer size ?
         mov     w0, w1      ;no, set N to the buffer size

         mov     #cmdbuf, w0 ;set start address of where to write the bytes
         ;
         ;   If the number of bytes to read is 0, skip the read and go straight
         ;   to sending the response.
         ;
         cp0     w1
         bra     z, gbufe_rsp ;no bytes to read from extended memory ?
;
;   Do the read from extended memory.
;
         mcall   exmem_getbuf ;read buffer from extended memory
;
;   Send the EXMEM_BUFDAT response.  The registers currently contain:
;
;     W0  -  Updated regular memory destination buffer address.
;
;     W1  -  Number of bytes in the read.
;
;     W3:W2  -  Updated extended memory source buffer address.
;
gbufe_rsp:
         mov     w0, w4      ;save regular mem buffer address in W4
         mov     w1, w5      ;save number of bytes read in W5

         gcall   cmd_lock_out ;acquire exclusive lock on the response stream
         mov     #[v rsp_exmem_bufdat], w0 ;send EXMEM_BUFDAT response opcode
         gcall   cmd_put8

         mov.d   w2, w0      ;send updated extended memory address
         gcall   cmd_put32

         mov     w4, w0      ;send updated regular memory address
         gcall   cmd_put16

         mov     w5, w0      ;send number of data bytes
         gcall   cmd_put8

         mov     #cmdbuf, w6 ;init pointer to first data byte
gbufe_byte:                  ;back here to send each new data byte
         cp0     w5
         skip_nz             ;still something left to send ?
         return              ;no, all done
         mov.b   [w6++], w0  ;get this data byte
         gcall   cmd_put8    ;send it
         sub     #1, w5      ;count one less byte left to do
         jump    gbufe_byte  ;back to do next byte
  /endif

;*******************************************************************************
;
;   Command EXMEM_GETBUFO adr n
;
;   Like EXMEM_GETBUFE except that the data is read into an odd-aligned buffer.
;
;   The maximum bytes that can be read is the size of the commands scratch
;   buffer - 1.
;
/if [Command cm_exmem_getbufo] then
         gcall   cmd_get32   ;get ADR into W3:W2
         mov.d   w0, w2
         gcall   cmd_get8    ;get N into w1
         mov     w0, w1
;
;   Clip N to the size of the commands scratch buffer - 1.
;
         gcall   cmd_bufsize ;get scratch buffer size in W0
         cp0     w0
         skip_z              ;already zero ?
         sub     #1, w0      ;account for unused even byte at start of buffer

         cp      w1, w0
         skip_leu            ;existing N is within the buffer size ?
         mov     w0, w1      ;no, set N to the buffer size

         mov     #cmdbuf, w0 ;set start address of where to write the bytes
         add     #1, w0      ;skip over first byte to start on odd byte
         ;
         ;   If the number of bytes to read is 0, skip the read and go straight
         ;   to sending the response.
         ;
         cp0     w1
         bra     z, gbufo_rsp ;no bytes to read from extended memory ?
;
;   Do the read from extended memory.
;
         mcall   exmem_getbuf ;read buffer from extended memory
;
;   Send the EXMEM_BUFDAT response.  The registers currently contain:
;
;     W0  -  Updated regular memory destination buffer address.
;
;     W1  -  Number of bytes in the read.
;
;     W3:W2  -  Updated extended memory source buffer address.
;
gbufo_rsp:
         mov     w0, w4      ;save regular mem buffer address in W4
         mov     w1, w5      ;save number of bytes read in W5

         gcall   cmd_lock_out ;acquire exclusive lock on the response stream
         mov     #[v rsp_exmem_bufdat], w0 ;send EXMEM_BUFDAT response opcode
         gcall   cmd_put8

         mov.d   w2, w0      ;send updated extended memory address
         gcall   cmd_put32

         mov     w4, w0      ;send updated regular memory address
         gcall   cmd_put16

         mov     w5, w0      ;send number of data bytes
         gcall   cmd_put8

         mov     #cmdbuf, w6 ;init pointer to first data byte
         add     #1, w6      ;skip over unused byte at even address
gbufo_byte:                  ;back here to send each new data byte
         cp0     w5
         skip_nz             ;still something left to send ?
         return              ;no, all done
         mov.b   [w6++], w0  ;get this data byte
         gcall   cmd_put8    ;send it
         sub     #1, w5      ;count one less byte left to do
         jump    gbufo_byte  ;back to do next byte
  /endif
