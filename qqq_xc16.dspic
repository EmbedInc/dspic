;   ***************************************************************
;   * Copyright (C) 2017, Embed Inc (http://www.embedinc.com)     *
;   *                                                             *
;   * Permission to copy this file is granted as long as this     *
;   * copyright notice is included in its entirety at the         *
;   * beginning of the file, whether the file is copied in whole  *
;   * or in part and regardless of whether other information is   *
;   * added to the copy.                                          *
;   *                                                             *
;   * The contents of this file may be used in any way,           *
;   * commercial or otherwise.  This file is provided "as is",    *
;   * and Embed Inc makes no claims of suitability for a          *
;   * particular purpose nor assumes any liability resulting from *
;   * its use.                                                    *
;   ***************************************************************
;
;   Routines for interfacing between code written in XC16 and the rest of the
;   system.
;
/include "qq2.ins.dspic"

;*******************************************************************************
;
;   Configuration constants.
;
/const   using_nvol bool = false ;whether non-volatile memory routines in use
/const   qqq_stacksz integer = 512 ;QQQ task stack size, bytes
;
;   Derived constants.
;
/block
  /var local ii integer
  /var local r real
  /var local s string

  /endblock

////////////////////////////////////////////////////////////////////////////////
//
//   Macro START_XC16_TASK name
//
//   Start a new task written in C.  NAME is the raw characters (not a string)
//   of the generic task name.  Other definitiions required:
//
//     <name>_RUN
//
//       Name of the C function that will run the task.  The processor is reset
//       if this function returns.
//
//     <name>_STACKSZ
//
//       Size of the RAM area dedicated to the task stack size in bytes.  This
//       is a preprocessor integer constant or variable.
//
//   W13 and W14 are trashed.
//
/macro start_xc16_task
  /var local name = [qstr [arg 1]] ;generic routine name

.section .ram_xc16, bss
alloc    stack_[chars name], [v [chars name]_stacksz], 2 ;task stack

.section .code_xc16, code
         mov     #[v [chars name]_stacksz], w13 ;pass stack size
         mov     #stack_[chars name], w14 ;pass stack start address
         call    task_new    ;create the new task
         goto    [lab task]  ;first instruction of the new task
         jump    [lab cont]  ;continue orginal task

[lab task]:                  ;new task
         gcall   _[chars name]_run ;call C routine that implements this task
         reset               ;reset processor if C routine ever returns

[lab cont]:
  /endmac

;*******************************************************************************
;
;   Variables.
;
;*******************
;
;   Global state.
;
.section .ram_xc16, bss


;*******************
;
;   Local state.
;


.section .code_xc16, code
;*******************************************************************************
;
;   Subroutine XC16_INIT
;
;   Initialize the hardware and software state managed by this module.
;
         glbsub  xc16_init

         leaverest

;*******************************************************************************
;
;   Subroutine QQQ_START
;
;   Start the QQQ task, which is implemented by the C function QQQ_RUN.
;
         glbsub  qqq_start, regf13 | regf14

         start_xc16_task qqq

         leaverest

;*******************************************************************************
;
;   C subroutine SYSTEM_RESET
;
;   Reset the processor.
;
         glbent  _system_reset

/if using_nvol then
         gcall   nvol_flush  ;make sure no cached but unwritten nvol data
  /endif

         reset

;*******************************************************************************
;
;   C subroutine DEBUG1 (word, string)
;
;   Sends a DBG1 response over the service port.  The intent is to have the
;   integer value and string displayed together.
;
/if [exist "rsp_dbg1"] then
         glbsubc debug1

         mov     w0, w2      ;save data word in W2
;
;   Register usage:
;
;     W0  -  Scratch
;
;     W1  -  Pointer to string byte
;
;     W2  -  Data word from caller
;
;     W3  -  Length of string in bytes
;
;
;   Look thru the string to determine how long it is.
;
         mov     w1, w3      ;init pointer to string byte
db1_len:                     ;back here to check each new byte
         cp0.b   [w3++]
         skip_z              ;found the terminating 0 ?
         jump    db1_len     ;no, go back and check next byte

         sub     w3, w1, w3  ;make total number of bytes examined
         sub     #1, w3      ;make number of bytes in the string
         and     #0xFF, w3   ;force to legal range
;
;   Send the DBG1 response.
;
         gcall   cmd_lock_out ;acquire lock on response stream
         mov     #rsp_dbg1, w0
         gcall   cmd_put8    ;DBG1 response opcode
         mov     w2, w0
         gcall   cmd_put16   ;data word from caller
         mov     w3, w0
         gcall   cmd_put8    ;number of characters in the string

         cp0     w3
         bra     z, db1_done ;no string bytes to send ?
db1_strbyte:                 ;back here each string byte
         mov.b   [w1++], w0  ;fetch this string byte
         gcall   cmd_put8    ;send it
         sub     #1, w3      ;count one less byte left to do
         bra     nz, db1_strbyte ;back to do next byte

db1_done:
         gcall   cmd_unlock_out ;release lock on response stream
         leaverest
  /endif

;*******************************************************************************
;
;   C subroutine DEBUG2 (word, string)
;
;   Sends a DBG2 response over the service port.  The intent is to have the
;   integer value and string displayed together.  On entry, the registers
;   contain:
;
;     W1:W0  -  32 bit value to display.
;
;     W2  -  Start of address of null-terminated string to display.
;
;   Register W0-W7 may be trashed.
;
/if [exist "rsp_dbg2"] then
         glbsubc debug2

         mov     w1, w4      ;save high word of data value
         mov     w2, w1      ;set pointer to string
         mov     w0, w2      ;save low word of data value
;
;   Register usage:
;
;     W0  -  Scratch
;
;     W1  -  Pointer to string byte
;
;     W2  -  Low word of 32 bit data value
;
;     W3  -  Length of string in bytes
;
;     W4  -  High word of 32 bit data value
;
;   Look thru the string to determine how long it is.
;
         mov     w1, w3      ;init pointer to string byte
db2_len:                     ;back here to check each new byte
         cp0.b   [w3++]
         skip_z              ;found the terminating 0 ?
         jump    db2_len     ;no, go back and check next byte

         sub     w3, w1, w3  ;make total number of bytes examined
         sub     #1, w3      ;make number of bytes in the string
         and     #0xFF, w3   ;force to legal range
;
;   Send the DBG2 response.
;
         gcall   cmd_lock_out ;acquire lock on response stream
         mov     #rsp_dbg2, w0
         gcall   cmd_put8    ;DBG2 response opcode
         mov     w4, w0
         gcall   cmd_put16   ;high words of 32 bit data
         mov     w2, w0
         gcall   cmd_put16   ;low word of 32 bit data
         mov     w3, w0
         gcall   cmd_put8    ;number of characters in the string

         cp0     w3
         bra     z, db2_done ;no string bytes to send ?
db2_strbyte:                 ;back here each string byte
         mov.b   [w1++], w0  ;fetch this string byte
         gcall   cmd_put8    ;send it
         sub     #1, w3      ;count one less byte left to do
         bra     nz, db2_strbyte ;back to do next byte

db2_done:
         gcall   cmd_unlock_out ;release lock on response stream
         leaverest
  /endif

;*******************************************************************************
;
;   C subroutines BUF_PUT8U (&BUF_P, &NBUF, DAT)
;                 BUF_PUT8S (&BUF_P, &NBUF, DAT)
;
;   Write a byte into a buffer.  BUF_P is the pointer to where to write the
;   byte.  It will be updated to point to the next byte.  NBUF is the number of
;   bytes in the buffer, which will be incremented by 1.  DAT is the byte to
;   write into the buffer.
;
         glbent  _buf_put8s
         glbsubc buf_put8u
;
;   Register contents:
;
;     W0  -  Address of BUF_P.
;
;     W1  -  Address of NBUF.
;
;     W2  -  Data byte in low 8 bits.
;
         mov     [w0], w3    ;get pointer to where to write the byte
         mov.b   w2, [w3++]  ;write the byte, advance pointer
         mov     w3, [w0]    ;update caller's pointer variable
         inc     [w1], [w1]  ;update callers byte counter

         leaverest

;*******************************************************************************
;
;   C subroutines BUF_PUT16U (&BUF_P, &NBUF, DAT)
;                 BUF_PUT16S (&BUF_P, &NBUF, DAT)
;
;   Write a 16 bit word into a byte buffer.  The word is written in most to
;   least significant byte order.  The word in the buffer may be arbitrarily
;   aligned.
;
;   BUF_P points to where to write the word on entry.  It will be updated to
;   point to immediately after the word.  NBUF is the number of bytes in the
;   buffer, and will be incremented by 2.  DAT is the word to write.
;
         glbent  _buf_put16s
         glbsubc buf_put16u
;
;   Register contents:
;
;     W0  -  Address of BUF_P.
;
;     W1  -  Address of NBUF.
;
;     W2  -  Data word.
;
         mov     [w0], w3    ;get pointer to where to write first byte
         swap    w2          ;get high byte into position
         mov.b   w2, [w3++]  ;write high byte, advance pointer
         swap    w2          ;get low byte into position
         mov.b   w2, [w3++]  ;write low byte, advance pointer
         mov     w3, [w0]    ;update caller's pointer variable
         inc2    [w1], [w1]  ;update callers byte counter

         leaverest

;*******************************************************************************
;
;   C function BUF_GET8U (&BUF_P, &NBUF)
;
;   Read a byte from a buffer.  BUF_P is pointing to where to read the byte
;   from.  It will be advanced to past the byte.  NBUF is the number of bytes
;   left to read in the buffer, and will be decremented by 1.
;
;   If NBUF is 0 on entry, then no byte is read, 0 is returned, and neither
;   BUF_P nor NBUF are altered.
;
;   The 0-255 byte value is returned as a whole word.
;
         glbsubc buf_get8u
;
;   Register contents:
;
;     W0  -  Address of BUF_P.
;
;     W1  -  Address of NBUF.
;
         mov     #0, w2      ;init return value for when buffer is exhausted
         cp0     [w1]
         bra     z, bget8_ret ;buffer is exhausted, go return 0 in W2
;
;   There is at least one byte left.
;
         mov     [w0], w3    ;get address of where to read byte from
         ze      [w3++], w2  ;read the byte, advance the address
         mov     w3, [w0]    ;update caller's pointer variable
         dec     [w1], [w1]  ;update caller's byte counter

bget8_ret:                   ;return the value in W2
         mov     w2, w0
         leaverest

;*******************************************************************************
;
;   C functions BUF_GET16U (&BUF_P, &NBUF)
;               BUF_GET16S (&BUF_P, &NBUF)
;
;   Read a 16 bit word from a byte buffer.  The word may be arbitrarily aligned.
;   The word is assumed to be stored in most to least significant byte order.
;
;   BUF_P is the pointer to the start of the word in the buffer.  It will be
;   udpated to immediately after the word.  NBUF is the number of bytes left to
;   read from the buffer.  It will be decremented by 2.
;
;   When the buffer has been fully read (NBUF = 0), no new bytes are read, NBUF
;   and BUF_P are not updated, and 0 is substituted for the byte value.
;
         glbent  _buf_get16s
         glbsubc buf_get16u
;
;   Register contents:
;
;     W0  -  Address of BUF_P.
;
;     W1  -  Address of NBUF.
;
         push    w0          ;temp save registers
         push    w1
         mcall   _buf_get8u  ;read high byte into W0
         sl      w0, #8, w2  ;get high byte into position, save in W2
         pop     w1          ;restore original W0, W1
         pop     w0

         push    w2          ;save word with high byte
         mcall   _buf_get8u  ;read low byte into W0
         pop     w1          ;get high byte into w1
         ior     w0, w1, w0  ;make full word value in W0

         leaverest

.end
